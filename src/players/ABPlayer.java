package players;

import composer.SComposer;
import java.util.Random;
import java.util.Scanner;

public abstract class ABPlayer {

    //The simple composer is the sole instance variable for this class.

    protected SComposer composer;

    /**
     * Create an ABPlayer, a performer which bases its work on strings of As and Bs.
     * It is basically a simple composer which processes the As and the Bs in the string, one at a time, by somehow sonically rendering them.
     * SPainter c is the workhorse painter
     */
    public ABPlayer(SComposer c){
        composer=c;
    }

    /**
     * Play a melody by processing the given string of A and B symbols.
     * The string named "line" is a string of As and Bs, presumable generated by some L-System. But there is a "twist"
     * An "add on" imposes stepwise motion, for the most part, on the melodic fragments to which the A and B are bound.
     */
    public void play(String line){
        composer.beginScore();
        composer.text();
        String motionLine=motionLine(line)+"S";
        int x=0;
        Scanner symbolString=new Scanner(line);
        while(symbolString.hasNext()){
            String symbol=symbolString.next();
            if(symbol.equals("A")){
                thingA();
            }else if(symbol.equals("B")){
                thingB();
            }
            if(symbolString.hasNext()){
                String direction=motionLine.substring(x,x+1);
                changePitch(composer,direction);
                x=x+1;
            }
        }
        composer.mms_31_JSB_M1();
        composer.untext();
        composer.saveScore();
    }

    private String motionLine(String line){
       System.out.println("line= "+line);
       int lineLength=lineLength(line);
       int motionLineLength=lineLength-1;
       String orderedMotionLine=orderedMotionLine(motionLineLength);
       String unorderedMotionLine=unorderedMotionLine(orderedMotionLine);
       System.out.println("Stepwise motion = "+unorderedMotionLine);
       return unorderedMotionLine;
    }

    private int lineLength(String line){
        if(line.equals("")){
            return 0;
        } else if(line.substring(0,1).equals(" ")){
            return lineLength(line.substring(1));
        }else{
            return 1+lineLength(line.substring(1));
        }
    }

    private String orderedMotionLine(int motionLineLength){
        if(motionLineLength==0){
            return "";
        }else if(motionLineLength==1){
            return "S";
        }else{
            return "RL"+orderedMotionLine(motionLineLength-2);
        }
    }

    private String unorderedMotionLine(String orderedMotionLine){
        if (orderedMotionLine.length()<2){
            return orderedMotionLine;
        }else{
            String element=pick(orderedMotionLine);
            String remainder=remove(element, orderedMotionLine);
            return element+unorderedMotionLine(remainder);
        }
    }
    private Random generator=new Random();

    private String pick(String orderedMotionLine){
        int rn=generator.nextInt(orderedMotionLine.length());
        return orderedMotionLine.substring(rn,rn+1);
    }

    private String remove(String element, String bag){
        int position=bag.indexOf(element);
        return bag.substring(0,position)+bag.substring(position+1);
    }

    private void changePitch(SComposer composer, String direction){
        if(direction.equalsIgnoreCase("R")){
            composer.rp();
        }else if(direction.equalsIgnoreCase("L")){
            composer.lp();
        }else if(direction.equalsIgnoreCase("S")){

        }
    }

    /**
     * Reference to an encodint of what it means to render the A symbol sonically
     */
    public abstract void thingA();

    /**
     * Reference to an encoding of what it means to render the B symbol sonically
     */
    public abstract void thingB();
}
